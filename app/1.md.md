徕卡全站仪测量 APP 后端架构设计文档（导线 / 碎步测量）
我的包名 com.example.leicameasurement  android版本16(api 36)

适用场景：Android 平台徕卡全站仪（TS60/TS30）导线测量、碎步点测量开发语言：Java核心目标：蓝牙稳定通信、多型号仪器适配、测量算法精准、数据不丢失架构原则：后端逻辑优先、模块解耦、可扩展、可维护

目录

架构整体设计

模块拆分与职责

核心业务流程

开发优先级与落地策略

关键模块代码框架

扩展与维护建议

一、架构整体设计

采用 “分层 + 模块化” 架构，从下到上覆盖 “基础设施→设备通信→算法计算→流程控制→前端展示”，确保各层职责单一、调用链路清晰，完全支撑 “蓝牙连接→仪器操作→测量计算→数据存储” 的核心需求。

1\.1 架构分层图

前端展示层（UI Layer）

流程控制层（Controller Layer）

设备通信层（Device Layer）

算法计算层（Calculation Layer）

基础设施层（Infrastructure Layer）

数据存储层（Data Layer）







1\.2 核心设计原则

链路稳定性优先：独立模块处理蓝牙连接、自动重连、数据校验，确保 “永远在线”；

仪器型号隔离：通过 “适配器模式” 适配不同徕卡型号，新增型号无需修改现有逻辑；

数据不可丢失：原始数据实时写入 WAL 日志，解算数据事务性存储，支持断点续测；

后端逻辑独立：前端仅做 “指令触发 + 结果展示”，核心业务逻辑全部放在后端模块。

二、模块拆分与职责

按 “功能内聚、职责单一” 原则，将 APP 拆分为 6 大核心模块，目录结构如下：

plaintext

com.example.totalstationapp/

│

├── ui/                # 前端展示层（仅做交互，无业务逻辑）

│   ├── activity/       # 页面容器（仅跳转与初始化Fragment）

│   │   ├── MainActivity.java       # 主页面（承载Fragment）

│   │   └── SettingsActivity.java   # 设置页面（后期补充）

│   ├── fragment/       # 功能页面（仅触发指令，展示结果）

│   │   ├── TraverseFragment.java    # 导线测量页面

│   │   ├── DetailPointFragment.java # 碎步点测量页面

│   │   └── LogFragment.java        # 日志查看页面（后期补充）

│   └── viewmodel/      # 状态容器（转发前端指令到后端）

│       ├── TraverseViewModel.java   # 导线测量ViewModel

│       ├── DetailPointViewModel.java# 碎步点测量ViewModel

│       └── SettingsViewModel.java   # 设置ViewModel（后期补充）

│

├── controller/         # 流程控制层（业务调度核心）

│   ├── MeasurementController.java   # 测量总入口（分发指令）

│   ├── TraverseController.java      # 导线测量流程（测站→后视→前视→平差）

│   ├── DetailPointController.java   # 碎步点测量流程（单次/批量测量）

│   └── AppStateManager.java         # 全局状态管理（当前任务/测站/连接状态）

│

├── device/             # 设备通信层（仪器交互核心）

│    ├── connection/           # 新增：连接抽象层

│    │   ├── IConnectionChannel.java     #连接通道接口

│    │   ├── IDataTransceiver.java       #数据收发接口

│    │   ├── IConnectionMonitor.java#    #连接监控接口

│    │   ├── ConnectionType.java         #连接类型枚举  

│    │   ├── ConnectionConfig.java       #连接配置基类

│    │   ├── ConnectionState.java        #连接状态枚举

│    │   └── ConnectionException.java    #连接异常类

│   ├── bluetooth/      # 蓝牙通信模块

│   │   ├── BluetoothChannel.java    # 蓝牙物理连接（Socket读写）

│   │   ├── DataTransceiver.java     # 数据收发（队列+超时重发）

│   │   ├── ConnectionMonitor.java   # 连接监控（心跳+断连检测）

│   │   ├── BluetoothLinkManager.java# #链路总控（状态机+自动重连）

│   │   └── AutoReconnectStrategy.java# #重连策略（指数退避）

│   ├── wifi/      # wifi通信模块

│   │   ├── WifiChannel.java            #wifi物理通道

│   │   ├── WifiTransceiver.java        #WiFi数据收发器

│   │   ├── WifiConnectionMonitor.java  #WiFi连接监控器

│   │   ├── WifiLinkManager.java        #WiFi链路管理器

│       └── WifiConfig.java             #WiFi配置类

│   ├── adapter/        # 仪器适配模块（多型号隔离）

│   │   ├── InstrumentAdapter.java   # 仪器适配接口（定义标准操作）

│   │   ├── TS60Adapter.java         # 徕卡TS60适配（实现接口）

│   │   ├── TS30Adapter.java         # 徕卡TS30适配（实现接口）

│   │   └── InstrumentFactory.java   # 仪器工厂（根据型号创建适配器）

│   └── protocol/       # 协议解析模块（GeoCOM协议处理）

│       ├── ProtocolConstants.java   # 协议常量（指令头/结束符/常用指令）

│       ├── ErrorCodes.java          # 错误码枚举（仪器返回码映射）

│       ├── GeoComCommandBuilder.java# 指令构建（将操作转为GeoCOM指令）

│       └── GeoComResponseParser.java# 响应解析（仪器字节流→结构化数据）

│

├── calculation/        # 算法计算层（测量核心算法）

│   ├── TraverseCalculator.java      # 导线测量总控（流程调度）

│   ├── CoordinateCalculator.java   # 坐标计算（正算/反算）

│   ├── ClosureErrorCalculator.java # 闭合差计算（角度/坐标闭合差）

│   ├── AdjustmentCalculator.java    # 平差计算（等权/加权平差）

│   ├── DetailPointCalculator.java   # 碎步点计算（相对坐标→绝对坐标）

│   └── ErrorChecker.java           # 误差校验（测量值超限检测）

│

├── data/               # 数据存储层（原始+解算数据）

│   ├── database/       # 解算数据存储（Room数据库）

│   │   ├── MeasurementDatabase.java # 数据库实例（单例）

│   │   ├── TraverseTaskDao.java     # 导线任务DAO（增删改查）

│   │   ├── TraverseStationDao.java  # 测站DAO

│   │   └── DetailPointDao.java      # 碎步点DAO

│   ├── entity/         # 数据实体（与数据库表对应）

│   │   ├── TraverseTask.java        # 导线任务实体（任务ID/状态/时间）

│   │   ├── TraverseStation.java     # 测站实体（任务ID/测站号/坐标/仪器高）

│   │   ├── DetailPoint.java         # 碎步点实体（点号/X/Y/Z/所属任务）

│   │   └── MeasurementParam.java   # 测量参数实体（仪器高/棱镜高/测量模式）

│   ├── repository/     # 数据仓库（统一数据访问入口）

│   │   ├── RawDataRepository.java   # 原始数据仓库（WAL日志查询）

│   │   ├── TraverseRepository.java  # 导线数据仓库

│   │   └── DetailPointRepository.java# 碎步点数据仓库

│   ├── wal/            # 原始数据日志（WAL）

│   │   ├── WalLogManager.java       # WAL日志总控

│   │   └── WalFileWriter.java       # 日志写入（实时追加）

│   └── exporter/       # 数据导出（后期补充）

│       ├── DataExporter.java        # 导出总控

│       └── CsvExporter.java        # CSV格式导出（基础版）

│

├── infrastructure/     # 基础设施层（通用工具）

│   ├── LogManager.java              # 日志管理（统一日志输出）

│   ├── ThreadExecutor.java          # 线程池（区分通信/计算/存储线程）

│   ├── PermissionHelper.java        # 权限申请（蓝牙/存储权限）

│   ├── ConfigManager.java           # 配置管理（存储仪器型号/蓝牙MAC）

│   └── DependencyInjector.java      # 依赖注入（后期优化，初期可省略）

│

└── utils/              # 通用工具类

├── MathUtils.java               # 数学工具（角度转换/距离计算）

├── FileUtils.java               # 文件工具（创建目录/删除文件）

├── DateUtils.java               # 时间工具（生成任务编号/日志命名）

└── StringUtils.java             # 字符串工具（指令格式化/校验）

三、核心业务流程

以 “导线测量” 为例，展示从 “前端触发→蓝牙通信→仪器操作→算法计算→数据存储” 的完整链路，确保各模块协作清晰。

3\.1 导线测量流程时序图

协议层

WalLogManager/MeasurementDatabase

TraverseCalculator

BluetoothLinkManager

InstrumentManager(TS60Adapter)

TraverseController

TraverseViewModel

TraverseFragment



点击“开始导线测量”（参数：起点坐标、仪器型号）

转发指令（startTraverse(param)）

检查蓝牙连接（未连接则触发连接）

返回连接状态（已连接）

执行测站设置（setStation(param)）

发送测站设置指令（GeoCOM格式）

接收仪器响应（设置成功）

返回测站设置完成

执行后视测量（measureBacksight()）

发送测量指令

接收原始测量数据（角度/距离）

解析数据（字节流→结构化坐标）

返回后视点坐标

返回后视点原始数据

计算后视方位角（calcAzimuth()）

返回方位角结果

1. 原始数据写入WAL 2. 测站/后视数据存入数据库

返回“后视测量完成”

显示下一步（测量前视点）

3\.2 关键保障机制

蓝牙断连重连：ConnectionMonitor 定时发送心跳包（如 \*IDN?），检测到断连后，AutoReconnectStrategy 按 “1s→3s→5s” 指数退避重连，重连成功后恢复当前测量状态；

数据不丢失：仪器返回的原始数据先写入 WAL 日志（WalFileWriter），再进行算法计算，确保即使计算失败，原始数据仍可追溯；

误差校验：ErrorChecker 实时校验测量值（如角度偏差 ±5″、距离往返差 1/2000），超限则提示重测。

四、开发优先级与落地策略

按 “核心需求→补充需求→优化需求” 分三阶段开发，避免一次性开发所有模块，降低启动门槛，快速验证核心功能。

4\.1 第一阶段：核心功能（2 周）

目标：实现 “蓝牙连接 + TS60 测量 + 基础导线计算 + 原始数据存储”，跑通最小测量流程。需开发模块 / 文件：

模块	核心文件	开发内容

ui 层	TraverseFragment.java+TraverseViewModel.java	极简导线测量页面，仅触发指令 + 显示结果

controller 层	TraverseController.java	导线流程调度（测站→后视→前视）

device/bluetooth	BluetoothChannel.java+DataTransceiver.java	蓝牙 Socket 连接、数据收发（队列 + 超时重发）

device/adapter	InstrumentAdapter.java+TS60Adapter.java	实现 TS60 的 “测站设置”“测量坐标” 指令

device/protocol	GeoComCommandBuilder.java+GeoComResponseParser.java	基础 GeoCOM 指令构建与解析（测量 / 设置指令）

calculation 层	TraverseCalculator.java+CoordinateCalculator.java	实现坐标正算、基础方位角计算

data/wal	WalFileWriter.java（极简版）	实时写入原始数据到日志文件

4\.2 第二阶段：补充功能（2 周）

目标：支持 TS30 型号、完整导线平差、解算数据存储。需开发模块 / 文件：

模块	核心文件	开发内容

device/adapter	TS30Adapter.java+InstrumentFactory.java	实现 TS30 适配，工厂模式选择仪器型号

calculation 层	ClosureErrorCalculator.java+AdjustmentCalculator.java	实现角度 / 坐标闭合差计算、加权平差

data/database	MeasurementDatabase.java+TraverseStationDao.java	Room 数据库初始化、测站 / 导线任务 DAO

data/entity	TraverseTask.java+TraverseStation.java	导线任务 / 测站实体（关联关系）

data/repository	TraverseRepository.java	导线数据仓库（统一数据库访问）

4\.3 第三阶段：优化功能（1 周）

目标：数据导出、日志查看、权限管理。需开发模块 / 文件：

模块	核心文件	开发内容

data/exporter	DataExporter.java+CsvExporter.java	实现导线 / 碎步点数据 CSV 导出

ui/fragment	LogFragment.java	日志查看页面（加载 WAL 日志）

infrastructure	PermissionHelper.java	蓝牙 / 存储权限动态申请

utils 层	FileUtils.java	文件导出路径管理

五、关键模块代码框架

提供核心模块的极简代码框架，覆盖 “蓝牙连接、仪器适配、算法计算、数据存储”，可直接复制开发。

5\.1 蓝牙连接模块（BluetoothChannel.java）

java

运行

package com.example.totalstationapp.device.bluetooth;

import android.bluetooth.BluetoothSocket;

import android.util.Log;

import com.example.totalstationapp.infrastructure.LogManager;

import java.io.IOException;

import java.io.InputStream;

import java.io.OutputStream;

import java.util.UUID;

/\*\*

* 蓝牙物理通道：负责Socket连接、字节流读写
* 核心职责：建立/关闭连接、发送指令、接收响应

\*/

public class BluetoothChannel {

// 徕卡SPP协议固定UUID

private static final UUID SPP\_UUID = UUID.fromString("00001101-0000-1000-8000-00805F9B34FB");

private static final String TAG = "BluetoothChannel";

private BluetoothSocket mSocket;

private OutputStream mOutputStream;

private InputStream mInputStream;

private String mDeviceMac; // 目标设备MAC地址

public BluetoothChannel(String deviceMac) {

this.mDeviceMac = deviceMac;

}

/\*\*

* 建立蓝牙连接
* @return true=连接成功，false=连接失败

\*/

public boolean connect() {

try {

// 1. 获取蓝牙设备（需提前确保蓝牙已开启）

android.bluetooth.BluetoothDevice device =

android.bluetooth.BluetoothAdapter.getDefaultAdapter().getRemoteDevice(mDeviceMac);

// 2. 创建Socket（SPP协议）

mSocket = device.createRfcommSocketToServiceRecord(SPP\_UUID);

// 3. 关闭扫描（扫描占用资源）

android.bluetooth.BluetoothAdapter.getDefaultAdapter().cancelDiscovery();

// 4. 建立连接（阻塞方法，建议在子线程调用）

mSocket.connect();

// 5. 初始化输入输出流

mOutputStream = mSocket.getOutputStream();

mInputStream = mSocket.getInputStream();

LogManager.i(TAG, "蓝牙连接成功，MAC：" + mDeviceMac);

return true;

} catch (IOException e) {

LogManager.e(TAG, "蓝牙连接失败：" + e.getMessage());

close(); // 连接失败时关闭资源

return false;

}

}

/\*\*

* 发送指令（GeoCOM格式）
* @param command 指令字符串（如"\*GEO::MEASURE\r\n"）
* @return true=发送成功

\*/

public boolean sendCommand(String command) {

if (mOutputStream == null || command == null) {

LogManager.w(TAG, "发送失败：输出流为空或指令无效");

return false;

}

try {

// 按ASCII编码发送（GeoCOM协议要求）

mOutputStream.write(command.getBytes("US-ASCII"));

mOutputStream.flush(); // 强制写入

LogManager.d(TAG, "发送指令：" + command.trim());

return true;

} catch (IOException e) {

LogManager.e(TAG, "发送指令失败：" + e.getMessage());

return false;

}

}

/\*\*

* 接收仪器响应（阻塞方法，需在子线程调用）
* @param timeout 超时时间（ms）
* @return 响应字符串（null=超时或失败）

\*/

public String receiveResponse(long timeout) {

if (mInputStream == null) {

LogManager.w(TAG, "接收失败：输入流为空");

return null;

}

try {

byte[] buffer = new byte[1024];

int bytesRead;

StringBuilder response = new StringBuilder();

long startTime = System.currentTimeMillis();

// 循环读取，直到超时或收到结束符（\r\n）

while (System.currentTimeMillis() - startTime < timeout) {

if (mInputStream.available() > 0) {

bytesRead = mInputStream.read(buffer);

response.append(new String(buffer, 0, bytesRead, "US-ASCII"));

// 检查是否包含结束符（GeoCOM协议结束符）

if (response.toString().endsWith("\r\n")) {

String resp = response.toString().trim();

LogManager.d(TAG, "接收响应：" + resp);

return resp;

}

}

Thread.sleep(100); // 避免空轮询占用CPU

}

LogManager.w(TAG, "接收超时（" + timeout + "ms）");

return null;

} catch (IOException | InterruptedException e) {

LogManager.e(TAG, "接收响应失败：" + e.getMessage());

return null;

}

}

/\*\*

* 关闭连接与流

\*/

public void close() {

try {

if (mInputStream != null) mInputStream.close();

if (mOutputStream != null) mOutputStream.close();

if (mSocket != null) mSocket.close();

LogManager.i(TAG, "蓝牙连接已关闭");

} catch (IOException e) {

LogManager.e(TAG, "关闭连接失败：" + e.getMessage());

}

}

/\*\*

* 检查连接状态
* @return true=已连接

\*/

public boolean isConnected() {

return mSocket != null && mSocket.isConnected();

}

}

5\.2 仪器适配模块（TS60Adapter.java）

java

运行

package com.example.totalstationapp.device.adapter;

import com.example.totalstationapp.device.bluetooth.BluetoothLinkManager;

import com.example.totalstationapp.device.protocol.GeoComCommandBuilder;

import com.example.totalstationapp.device.protocol.GeoComResponseParser;

import com.example.totalstationapp.utils.LogManager;

/\*\*

* 徕卡TS60全站仪适配器：实现InstrumentAdapter接口，封装TS60专属指令

\*/

public class TS60Adapter implements InstrumentAdapter {

private static final String TAG = "TS60Adapter";

private BluetoothLinkManager mLinkManager; // 蓝牙链路管理

private GeoComCommandBuilder mCommandBuilder; // 指令构建器

private GeoComResponseParser mResponseParser; // 响应解析器

public TS60Adapter(BluetoothLinkManager linkManager) {

this.mLinkManager = linkManager;

this.mCommandBuilder = new GeoComCommandBuilder();

this.mResponseParser = new GeoComResponseParser();

}

/\*\*

* 执行测站设置
* @param stationX 测站X坐标（m）
* @param stationY 测站Y坐标（m）
* @param stationH 测站高程（m）
* @param instrumentHeight 仪器高（m）
* @return true=设置成功

\*/

@Override

public boolean setStation(double stationX, double stationY, double stationH, double instrumentHeight) {

// 1. 构建TS60测站设置指令（GeoCOM格式）

String command = mCommandBuilder.buildSetStationCommand(stationX, stationY, stationH, instrumentHeight);

// 2. 发送指令（超时5000ms）

String response = mLinkManager.sendAndReceive(command, 5000);

// 3. 解析响应（判断是否成功）

return mResponseParser.isCommandSuccess(response);

}

/\*\*

* 测量后视点（获取方位角）
* @param prismHeight 棱镜高（m）
* @return 后视点数据（double[0]=水平角, double[1]=垂直角, double[2]=斜距；null=测量失败）

\*/

@Override

public double[] measureBacksight(double prismHeight) {

// 1. 构建测量指令（单次精测）

String command = mCommandBuilder.buildMeasureCommand(prismHeight, MeasureMode.PRECISION);

// 2. 发送指令并接收响应

String response = mLinkManager.sendAndReceive(command, 10000); // 测量超时10s

if (response == null) return null;

// 3. 解析响应为角度/距离（弧度+米）

return mResponseParser.parseMeasureData(response);

}

/\*\*

* 测量前视点（导线测量）
* @param prismHeight 棱镜高（m）
* @return 前视点坐标（double[0]=X, double[1]=Y, double[2]=H；null=测量失败）

\*/

@Override

public double[] measureForepoint(double prismHeight) {

// 1. 测量角度+距离

double[] measureData = measureBacksight(prismHeight);

if (measureData == null) return null;

// 2. 此处需结合测站坐标和方位角计算前视点坐标（实际由算法层处理）

// 本方法仅返回测量原始数据，坐标计算由TraverseCalculator处理

return measureData;

}

/\*\*

* 关闭适配器（释放资源）

\*/

@Override

public void close() {

// 发送TS60关闭测量的指令（可选）

String command = mCommandBuilder.buildStopMeasureCommand();

mLinkManager.sendCommand(command);

LogManager.i(TAG, "TS60适配器已关闭");

}

}

5\.3 数据存储模块（WalFileWriter.java）

java

运行

package com.example.totalstationapp.data.wal;

import android.os.Environment;

import com.example.totalstationapp.utils.FileUtils;

import com.example.totalstationapp.utils.LogManager;

import java.io.File;

import java.io.FileWriter;

import java.io.IOException;

/\*\*

* WAL日志写入器（极简版）：实时保存仪器原始数据，确保不丢失
* 核心职责：追加写入原始数据（时间戳+指令+响应）

\*/

public class WalFileWriter {

private static final String TAG = "WalFileWriter";

private static final String WAL\_DIR = "totalstation\_wal"; // 日志目录

private static final String WAL\_FILE\_NAME = "raw\_data.log"; // 日志文件名

private FileWriter mFileWriter;

private File mWalFile;

public WalFileWriter() {

initWalFile();

}

/\*\*

* 初始化WAL文件（内部存储/外部存储）

\*/

private void initWalFile() {

try {

// 1. 创建日志目录（外部存储，便于调试）

File walDir = new File(Environment.getExternalStorageDirectory(), WAL\_DIR);

if (!walDir.exists()) {

if (walDir.mkdirs()) {

LogManager.i(TAG, "WAL目录创建成功：" + walDir.getAbsolutePath());

} else {

LogManager.e(TAG, "WAL目录创建失败");

return;

}

}

// 2. 创建日志文件（追加模式）

mWalFile = new File(walDir, WAL\_FILE\_NAME);

mFileWriter = new FileWriter(mWalFile, true);

LogManager.i(TAG, "WAL文件初始化成功：" + mWalFile.getAbsolutePath());

} catch (IOException e) {

LogManager.e(TAG, "WAL文件初始化失败：" + e.getMessage());

}

}

/\*\*

* 写入原始数据到WAL日志
* @param command 发送的指令
* @param response 接收的响应

\*/

public void writeRawData(String command, String response) {

if (mFileWriter == null) {

LogManager.w(TAG, "WAL写入失败：文件写入器为空");

return;

}

try {

// 日志格式：时间戳|指令|响应（便于后期解析）

String logLine = System.currentTimeMillis() + "|" +

command.trim() + "|" +

(response == null ? "NULL" : response.trim()) + "\n";

mFileWriter.write(logLine);

mFileWriter.flush(); // 强制写入磁盘（避免内存缓存丢失）

LogManager.d(TAG, "WAL写入成功：" + logLine.trim());

} catch (IOException e) {

LogManager.e(TAG, "WAL写入失败：" + e.getMessage());

}

}

/\*\*

* 关闭写入器

\*/

public void close() {

if (mFileWriter != null) {

try {

mFileWriter.close();

LogManager.i(TAG, "WAL写入器已关闭");

} catch (IOException e) {

LogManager.e(TAG, "WAL写入器关闭失败：" + e.getMessage());

}

}

}

/\*\*

* 获取WAL文件路径（用于调试/导出）
* @return 文件路径

\*/

public String getWalFilePath() {

return mWalFile != null ? mWalFile.getAbsolutePath() : null;

}

}

六、扩展与维护建议

6\.1 新增仪器型号（如 TS20）

新建 TS20Adapter.java，实现 InstrumentAdapter 接口；

在 InstrumentFactory.java 中添加型号判断逻辑：

java

运行

public InstrumentAdapter createInstrument(String model, BluetoothLinkManager linkManager) {

switch (model) {

case "TS60":

return new TS60Adapter(linkManager);

case "TS30":

return new TS30Adapter(linkManager);

case "TS20":

return new TS20Adapter(linkManager); // 新增TS20适配

default:

throw new IllegalArgumentException("不支持的仪器型号：" + model);

}

}

无需修改其他模块，完全符合 “开闭原则”。

6\.2 数据导出扩展（如 DXF 格式）

新建 DxfExporter.java，实现 DataExporter 接口；

在 DataExporter 中添加导出方法：

java

运行

public interface DataExporter {

boolean exportCsv(List<DetailPoint> points, String path);

boolean exportDxf(List<DetailPoint> points, String path); // 新增DXF导出

}

前端添加 “导出为 DXF” 按钮，调用 DetailPointRepository.exportData(ExportType.DXF)。

6\.3 常见问题排查

蓝牙连接失败：检查 BluetoothChannel 的 connect() 方法，确认 MAC 地址正确、SPP UUID 正确、蓝牙已开启；

仪器无响应：检查 DataTransceiver 的超时时间（测量指令建议 10s）、GeoComCommandBuilder 的指令格式（是否符合 TS60/TS30 的 GeoCOM 协议）；

数据丢失：检查 WalFileWriter 的 writeRawData() 是否在每次测量后调用、日志文件是否有写入权限。

附录：核心常量与错误码

1. 1 协议常量（ProtocolConstants.java）

java

运行

package com.example.totalstationapp.device.protocol;

/\*\*

* GeoCOM协议常量：避免硬编码

\*/

public class ProtocolConstants {

// 指令头（GeoCOM协议要求）

public static final String COMMAND\_HEADER = "\*";

// 指令结束符（CR+LF）

public static final String COMMAND\_TERMINATOR = "\r\n";

// 常用指令（TS60）

public static final String CMD\_SET\_STATION = "GEO::SETSTATION"; // 测站设置

public static final String CMD\_MEASURE = "GEO::MEASURE"; // 测量指令

public static final String CMD\_STOP\_MEASURE = "GEO::STOPMEASURE"; // 停止测量

// 成功响应标识

public static final String RESPONSE\_SUCCESS = "0";

}

1. 2 错误码（ErrorCodes.java）

java

运行

package com.example.totalstationapp.device.protocol;

/\*\*

* 仪器错误码：映射徕卡返回的错误码，便于前端显示

\*/

public enum ErrorCodes {

INVALID\_COMMAND(0x01, "无效指令，请检查指令格式"),

TARGET\_TOO\_FAR(0x05, "目标太远，无法测量"),

SIGNAL\_TOO\_WEAK(0x08, "信号太弱，请调整目标"),

DEVICE\_BUSY(0x0A, "仪器忙，请稍后重试"),

UNKNOWN\_ERROR(0xFF, "未知错误");

private final int code;

private final String message;

ErrorCodes(int code, String message) {

this.code = code;

this.message = message;

}

// 根据错误码获取描述

public static String getMessageByCode(int code) {

for (ErrorCodes error : values()) {

if (error.code == code) {

return error.message;

}

}

return UNKNOWN\_ERROR.message;

}
指令集总结 ：
一、通信基础指令集（COM subsystem）
核心用途：初始化蓝牙通信、配置通信参数、检查连接状态，是所有仪器操作的前置基础。
指令功能	ASCII 协议格式（请求 / 响应）	关键参数说明	开发用途
初始化 GeoCOM 连接	请求：%R1Q,111:1^m（COM_SwitchOnTPS，1 = 远程启动模式）
响应：%R1P,0,0:0^m（0 = 成功）	eOnMode=1（COM_TPS_STARTUP_REMOTE，远程启动允许 RPC 调用）	启动全站仪并进入 GeoCOM 模式，替代手动操作仪器开启蓝牙通信。
打开蓝牙串口连接	请求：无需 ASCII 手动发送（通过COM_OpenConnection函数，参数含端口 / 波特率 / 重试次数）	ePort（COM1-4）、eBaud（默认 19200）、nRetries（1-4 次，应对仪器启动延迟）	建立手机与全站仪的蓝牙 SPP 连接，需先确保仪器已启用 GeoCOM 模式（配置→接口→GeoCOM）。
检查通信连通性	请求：%R1Q,0:^m（COM_NullProc，RPC=0）
响应：%R1P,0,0:0^m（0 = 连通）	无参数，纯心跳检测	蓝牙连接后验证通信是否正常，重连后确认仪器是否响应。
设置通信超时时间	请求：%R1Q,114:5^m（COM_SetTimeOut，RPC=114，5=5 秒）
响应：%R1P,0,0:0^m	nTimeOut（7-60 秒，测量操作建议设 10-20 秒，避免超时）	防止蓝牙通信延迟导致误判失败（如全站仪测量耗时较长时，避免提前超时）。
关闭通信连接	请求：无需 ASCII 手动发送（通过COM_CloseConnection函数）
响应：无（直接关闭串口）	无参数	APP 退出或切换设备时调用，释放蓝牙资源，避免占用串口。
获取仪器软件版本	请求：%R1Q,110:^m（COM_GetSWVersion，RPC=110）
响应：%R1P,0,0:0,1,5,0^m	响应参数：nRel=1（主版本）、nVer=5（次版本）、nSubVer=0（子版本）	适配不同固件版本的指令差异（如 TS30 V1.50 与 V1.20 的部分测量指令格式不同）。
二、仪器状态与配置指令集（CSV subsystem）
核心用途：获取仪器基础信息、配置测量参数（如测站坐标、仪器高），是测量前的 “参数初始化” 关键。
指令功能	ASCII 协议格式（请求 / 响应）	关键参数说明	开发用途
设置测站坐标与仪器高	请求：%R1Q,2010:5000.0,3000.0,100.0,1.5^m（TMC_SetStation，RPC=2010）
响应：%R1P,0,0:0^m	参数顺序：dE0（东坐标）、dN0（北坐标）、dH0（高程）、dHi（仪器高，单位 m）	导线测量前设置测站基准，所有后续测量均基于此坐标计算。
获取测站坐标	请求：%R1Q,2009:^m（TMC_GetStation，RPC=2009）
响应：%R1P,0,0:0,5000.0,3000.0,100.0,1.5^m	响应参数同TMC_SetStation，用于验证测站设置是否正确。	测站设置后校验参数，避免输入错误导致后续计算偏差。
设置棱镜高	请求：%R1Q,2012:1.6^m（TMC_SetHeight，RPC=2012，1.6 = 棱镜高 m）
响应：%R1P,0,0:0^m	dHr（棱镜高，0.1-10m，超出范围返回GRC_IVPARAM错误）	碎步点测量时，根据棱镜类型（如迷你棱镜 1.3m、360° 棱镜 1.6m）动态设置。
获取仪器序列号与型号	请求：%R1Q,5003:^m（CSV_GetInstrumentNo，RPC=5003）
响应：%R1P,0,0:0,123456^m	响应参数：SerialNo（仪器序列号）	识别当前连接的仪器型号（TS30/TM30），自动加载对应指令适配逻辑（如 TS30 支持快速测量指令）。
设置大气校正参数	请求：%R1Q,2028:0.635,1013,25,20^m（TMC_SetAtmCorr，RPC=2028）
响应：%R1P,0,0:0^m	参数顺序：dLambda（EDM 波长 m）、dPressure（气压 hPa）、dDryTemp（干温℃）、dWetTemp（湿温℃）	消除大气折射对距离测量的影响，提升导线测量精度（尤其长距离测量）。
三、核心测量控制指令集（TMC subsystem）
核心用途：触发角度 / 距离测量、获取测量原始数据，是导线 / 碎步点测量的核心执行指令。
指令功能	ASCII 协议格式（请求 / 响应）	关键参数说明	开发用途
启动单次角度 + 距离测量	请求：%R1Q,2008:1,1^m（TMC_DoMeasure，RPC=2008；1 = 默认测量模式，1 = 自动倾角校正）
响应：%R1P,0,0:0^m	Command=1（TMC_DEF_DIST，默认测量）、Mode=1（TMC_AUTO_INC，自动倾角校正）	导线测量中 “后视点 / 前视点” 的单次测量，触发仪器同时采集水平角、垂直角、斜距。
获取测量结果（角度 + 距离）	请求：%R1Q,2108:1000,1^m（TMC_GetSimpleMea，RPC=2108；1000 = 等待时间 ms，1 = 自动倾角）
响应：%R1P,0,0:0,0.9973,1.6134,135.81^m	响应参数：dHz（水平角，rad）、dV（垂直角，rad）、dSlopeDist（斜距，m）	读取测量结果，需注意角度单位为弧度，需转换为度分秒（1rad≈57.2958°）用于显示。
启动跟踪测量（碎步点）	请求：%R1Q,2008:8,1^m（TMC_DoMeasure，Command=8= TMC_RTRK_DIST，跟踪模式）
响应：%R1P,0,0:0^m	Command=8（跟踪模式，每秒 10 次数据刷新）	碎步点批量测量（如快速采集多个地形点），配合TMC_GetSimpleMea实时获取坐标。
设置水平角定向	请求：%R1Q,2113:0.0^m（TMC_SetOrientation，RPC=2113，0.0 = 定向角度 rad）
响应：%R1P,0,0:0^m	HzOrientation（定向角度，如后视点方位角，rad）	导线测量 “后视定向” 步骤，将当前水平角设为已知方位角（如 0° 或后视点计算方位角）。
获取坐标结果（E/N/H）	请求：%R1Q,2082:1000,1^m（TMC_GetCoordinate，RPC=2082；1000 = 等待 ms，1 = 自动倾角）
响应：%R1P,0,0:0,5010.23,3008.45,101.25^m	响应参数：dE（东坐标）、dN（北坐标）、dH（高程），单位 m	直接获取仪器计算后的三维坐标，无需手动转换（仪器已自动应用大气校正、棱镜常数）。
四、电机控制与自动瞄准指令集（AUT/MOT subsystem）
核心用途：控制全站仪电机旋转、自动瞄准目标（ATR），适用于 “自动搜索目标”“精准照准” 场景（如导线测量后视点自动对准）。
指令功能	ASCII 协议格式（请求 / 响应）	关键参数说明	开发用途
自动瞄准目标（ATR）	请求：%R1Q,9037:0.08,0.08,0^m（AUT_FineAdjust，RPC=9037；0.08 = 搜索范围 rad≈5°）
响应：%R1P,0,0:0^m	dSrchHz/dSrchV（水平 / 垂直搜索范围，rad）、bDummy=0（预留参数）	导线测量中 “自动照准后视点”，无需手动转动仪器，提升瞄准精度（±1″）。
旋转仪器到指定角度	请求：%R1Q,9027:1.5708,1.0472,1,0,0^m（AUT_MakePositioning，RPC=9027）
响应：%R1P,0,0:0^m	参数顺序：Hz（目标水平角 rad）、V（目标垂直角 rad）、POSMode=1（精准模式）、ATRMode=0（按角度定位）、bDummy=0	碎步点测量中 “按坐标反算角度并旋转仪器”，提前对准目标点，减少手动操作。
读取 ATR 锁定状态	请求：%R1Q,6021:^m（MOT_ReadLockStatus，RPC=6021）
响应：%R1P,0,0:0,1^m（1 = 锁定成功）	响应参数：Status=1（MOT_LOCKED_IN，锁定目标）、0 = 未锁定	验证 ATR 是否成功锁定棱镜，避免未瞄准导致测量数据无效。
设置电机旋转速度	请求：%R1Q,6004:0.1,0.05^m（MOT_SetVelocity，RPC=6004）
响应：%R1P,0,0:0^m	参数：HZ-Speed=0.1rad/s（水平旋转速度）、V-Speed=0.05rad/s（垂直速度）	手动控制仪器旋转时（如寻找目标），设置合适速度（快速粗调 / 慢速精调）。
五、数据存储与导出指令集（FTR subsystem）
核心用途：读取仪器内部测量数据、导出原始日志，用于 “数据备份”“离线分析” 场景（如导出导线测量原始记录）。
指令功能	ASCII 协议格式（请求 / 响应）	关键参数说明	开发用途
列出仪器内部测量文件	请求：%R1Q,23306:1,170,"*.jpg"^m（FTR_SetupList，RPC=23306；1=CF 卡，170 = 图像文件）
响应：%R1P,0,0:0^m	eDeviceType=1（FTR_DEVICE_PCPARD，CF 卡）、eFileType=170（图像文件）	查看仪器存储的测量日志（如 GSI 格式）或图像文件，用于导出备份。
下载测量文件	请求：%R1Q,23303:1,170,"MEAS_001.GSI",450^m（FTR_SetupDownload，RPC=23303）
响应：%R1P,0,0:0,10^m	参数：szFileNameSrc（文件名）、unBlockSize=450（最大块大小）、响应unNumOfBlocks=10（总块数）	导出仪器内存储的导线测量原始数据（GSI 格式），用于 PC 端后续处理（如平差软件）。
删除仪器内文件	请求：%R1Q,23309:1,170,0,0,0,"MEAS_001.GSI"^m（FTR_Delete，RPC=23309）
响应：%R1P,0,0:0,1^m	unNumFilesDeleted=1（删除文件数）	清理仪器存储空间（如旧的测量日志），避免内存不足。
六、错误处理与状态查询指令集
核心用途：排查测量异常（如无目标、通信超时）、获取仪器状态（电量、温度），确保测量流程稳定。
指令功能	ASCII 协议格式（请求 / 响应）	关键参数说明	开发用途
获取错误信息	请求：%R1Q,36:3077^m（COM_GetErrorText，RPC=36；3077 = 错误码）
响应：%R1P,0,0:0,"Communication timed out"^m	Result=3077（GRC_COM_TIMEDOUT，通信超时）	将仪器返回的数字错误码转为中文提示（如 3077→“通信超时，请检查蓝牙连接”）。
检查仪器电量	请求：%R1Q,5039:^m（CSV_CheckPower，RPC=5039）
响应：%R1P,0,0:0,80,2,2^m	响应参数：unCapacity=80（电量百分比）、eActivePower=2（内置电池）	测量前提醒用户充电（如电量 < 20% 时弹窗警告），避免中途断电数据丢失。
检查测量数据有效性	请求：%R1Q,2114:^m（TMC_IfDataAzeCorrError，RPC=2114）
响应：%R1P,0,0:0,0^m	响应bAtrCorrectionError=0（无 ATR 校正错误，数据有效）	测量后校验数据是否因 “ATR 未锁定”“倾角超差” 导致无效，避免错误数据进入计算。